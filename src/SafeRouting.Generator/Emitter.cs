using Microsoft.CodeAnalysis;
using System.CodeDom.Compiler;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace SafeRouting.Generator
{
  internal static class Emitter
  {
    public static string Emit(IEnumerable<IMvcObjectInfo> items, GeneratorOptions options, CancellationToken cancellationToken)
    {
      var builder = new StringBuilder();
      using var stringWriter = new StringWriter(builder);
      using var writer = new IndentedTextWriter(stringWriter, "  ");

      writer.WriteLine("// <auto-generated/>");
      writer.WriteLine();
      writer.WriteLine("#pragma warning disable");
      writer.WriteLine("#nullable enable");
      writer.WriteLine();
      writer.WriteLine($"namespace {options.GeneratedNamespace}");
      writer.WriteLine("{");
      writer.Indent++;

      var itemIndex = 0;

      foreach (var item in items.OrderBy(x => x.OutputClassName))
      {
        cancellationToken.ThrowIfCancellationRequested();

        if (itemIndex++ != 0)
        {
          writer.WriteLine();
        }

        var classNamespace = $"{(item.Area is null ? null : $"Areas.{item.Area}.")}{item.Noun}s";
        var supportNamespace = $"Support.{(item.Area is null ? null : $"{item.Area}_")}{item.Noun}s_{item.OutputClassName}";

        writer.WriteLine($"namespace {classNamespace}");
        writer.WriteLine("{");
        writer.Indent++;

        WriteMethodClass(writer, options, item, supportNamespace);

        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
        writer.WriteLine($"namespace {supportNamespace}");
        writer.WriteLine("{");
        writer.Indent++;

        var namespaceItemIndex = 0;

        if (item.Properties.Count > 0)
        {
          WritePropertyDataClass(writer, options, item);
          namespaceItemIndex++;
        }

        foreach (var method in item.Methods)
        {
          if (namespaceItemIndex++ != 0)
          {
            writer.WriteLine();
          }

          WriteRouteValuesClass(writer, options, item, method);
        }

        writer.Indent--;
        writer.WriteLine("}");
      }

      writer.Indent--;
      writer.WriteLine("}");

      return builder.ToString();
    }

    private static void WriteMethod(IndentedTextWriter writer, IMvcObjectInfo item, IMvcMethodInfo method, string uniqueName)
    {
      var parameters = method.GetUrlParameters().ToArray();
      var returnType = $"{uniqueName}RouteValues";

      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Generates route values for <see cref=\"{CSharpSupport.EscapeXmlDocType($"{item.FullyQualifiedTypeName}.{method.FullyQualifiedMethodDeclaration}")}\"/>.");
      writer.WriteLine("/// </summary>");
      writer.Write($"public static {returnType} {method.EscapedName}(");

      if (parameters.Length > 0)
      {
        WriteMethodParameters(writer, parameters);
      }

      // Start of method block
      writer.WriteLine(")");
      writer.WriteLine("{");
      writer.Indent++;

      writer.WriteLine($"var routeInfo = new {returnType}();");

      writer.Write("routeInfo.RouteValues[\"area\"] = \"");
      if ((method.Area ?? item.Area) is string area)
      {
        writer.Write(CSharpSupport.EscapeStringLiteral(area));
      }
      writer.WriteLine("\";");

      foreach (var parameter in parameters)
      {
        writer.WriteLine($"routeInfo[routeInfo.Parameters.{CSharpSupport.CamelToPascalCase(parameter.Name)}] = {parameter.Name};");
      }

      writer.WriteLine("return routeInfo;");

      // End of method block
      writer.Indent--;
      writer.WriteLine("}");
    }
    private static void WriteMethodClass(IndentedTextWriter writer, GeneratorOptions options, IMvcObjectInfo item, string supportNamespace)
    {
      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Generates route values for <see cref=\"{CSharpSupport.EscapeXmlDocType(item.FullyQualifiedTypeName)}\"/>.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine(CSharpSupport.GetGeneratedCodeAttribute());
      writer.WriteLine(CSharpSupport.GetExcludeFromCodeCoverageAttribute());
      writer.WriteLine($"{options.GeneratedAccessModifier} static class {item.OutputClassName}");
      writer.WriteLine("{");
      writer.Indent++;

      var methodIndex = 0;

      foreach (var method in item.Methods)
      {
        if (methodIndex++ != 0)
        {
          writer.WriteLine();
        }

        WriteMethod(writer, item, method, $"{supportNamespace}.{method.UniqueName}");
      }

      writer.Indent--;
      writer.WriteLine("}");
    }
    private static void WriteMethodParameters(IndentedTextWriter writer, MvcMethodParameterInfo[] parameters)
    {
      var indentLevel = writer.Indent;
      var annotationsEnabled = true;
      var parameterIndex = 0;

      foreach (var parameter in parameters)
      {
        if (parameterIndex++ != 0)
        {
          writer.Write(", ");
        }

        if (parameter.Type.AnnotationsEnabled != annotationsEnabled)
        {
          annotationsEnabled = parameter.Type.AnnotationsEnabled;
          writer.WriteLine();
          writer.Indent = 0;
          writer.WriteLine(annotationsEnabled ? "#nullable restore" : "#nullable disable");
          writer.Indent = indentLevel + 1;
        }

        writer.Write($"{parameter.Type.FullyQualifiedName} {parameter.Name}");

        if (parameter.HasExplicitDefault)
        {
          var valueString = (parameter.Type.FullyQualifiedName, parameter.ExplicitDefaultValue) switch
          {
            // Use default keyword for null to handle default struct values
            (_, null) => "default",

            (_, bool boolValue) => boolValue ? "true" : "false",
            (_, char charValue) => $"'{CSharpSupport.EscapeCharLiteral(charValue)}'",
            (_, string stringValue) => $"\"{CSharpSupport.EscapeStringLiteral(stringValue)}\"",

            // Cast to the designated type in case of enum values which come in as ints
            (not "int", int intValue) => FormattableString.Invariant($"({parameter.Type.FullyQualifiedName}){intValue:D}"),

            // Get the string value for anything else
            (_, var value) => value.ToString()
          };

          writer.Write(" = ");
          writer.Write(valueString);
        }
      }

      if (!annotationsEnabled)
      {
        writer.Indent = 0;
        writer.WriteLine();
        writer.WriteLine("#nullable restore");
      }

      writer.Indent = indentLevel;
    }
    private static void WriteParameterDataClass(IndentedTextWriter writer, GeneratorOptions options, IMvcObjectInfo item, IMvcMethodInfo method)
    {
      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Represents route keys for parameters to <see cref=\"{CSharpSupport.EscapeXmlDocType($"{item.FullyQualifiedTypeName}.{method.FullyQualifiedMethodDeclaration}")}\"/>.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine(CSharpSupport.GetGeneratedCodeAttribute());
      writer.WriteLine(CSharpSupport.GetExcludeFromCodeCoverageAttribute());
      writer.WriteLine($"{options.GeneratedAccessModifier} sealed class ParameterData");
      writer.WriteLine("{");
      writer.Indent++;

      var parameterIndex = 0;
      foreach (var parameter in method.Parameters)
      {
        if (parameterIndex++ != 0)
        {
          writer.WriteLine();
        }

        writer.WriteLine("/// <summary>");
        writer.WriteLine($"/// Route key for the <c>{parameter.OriginalName}</c> parameter in <see cref=\"{CSharpSupport.EscapeXmlDocType($"{item.FullyQualifiedTypeName}.{method.FullyQualifiedMethodDeclaration}")}\"/>.");
        writer.WriteLine("/// </summary>");
        WriteRouteKeyProperty(writer,
          scopeType: "ParameterData",
          valueType: parameter.Type,
          propertyName: CSharpSupport.CamelToPascalCase(parameter.Name),
          keyName: parameter.BindingSource?.Name ?? parameter.OriginalName);
      }

      writer.Indent--;
      writer.WriteLine("}");
    }
    private static void WritePropertyDataClass(IndentedTextWriter writer, GeneratorOptions options, IMvcObjectInfo item)
    {
      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Represents route keys for the properties of <see cref=\"{CSharpSupport.EscapeXmlDocType(item.FullyQualifiedTypeName)}\"/>.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine(CSharpSupport.GetGeneratedCodeAttribute());
      writer.WriteLine(CSharpSupport.GetExcludeFromCodeCoverageAttribute());
      writer.WriteLine($"{options.GeneratedAccessModifier} sealed class PropertyData");
      writer.WriteLine("{");
      writer.Indent++;

      var propertyIndex = 0;
      foreach (var property in item.Properties)
      {
        if (propertyIndex++ != 0)
        {
          writer.WriteLine();
        }

        writer.WriteLine("/// <summary>");
        writer.WriteLine($"/// Route key for the property <see cref=\"{CSharpSupport.EscapeXmlDocType(item.FullyQualifiedTypeName)}.{property.OriginalName}\"/>.");
        writer.WriteLine("/// </summary>");
        WriteRouteKeyProperty(writer,
          scopeType: "PropertyData",
          valueType: property.Type,
          propertyName: property.Name,
          keyName: property.BindingSource?.Name ?? property.OriginalName);
      }

      writer.Indent--;
      writer.WriteLine("}");
    }
    private static void WriteRouteKeyProperty(IndentedTextWriter writer, string scopeType, TypeInfo valueType, string propertyName, string keyName)
    {
      var indentLevel = writer.Indent;

      if (!valueType.AnnotationsEnabled)
      {
        writer.Indent = 0;
        writer.WriteLine("#nullable disable");
        writer.Indent = indentLevel;
      }

      writer.Write($"public global::{GeneratorSupport.RootNamespace}.RouteKey<{scopeType}, {valueType.FullyQualifiedName}> {propertyName}");
      writer.Write(" { get; } = new global::");
      writer.WriteLine($"{GeneratorSupport.RootNamespace}.RouteKey<{scopeType}, {valueType.FullyQualifiedName}>(\"{CSharpSupport.EscapeStringLiteral(keyName)}\");");

      if (!valueType.AnnotationsEnabled)
      {
        writer.Indent = 0;
        writer.WriteLine("#nullable restore");
        writer.Indent = indentLevel;
      }
    }
    private static void WriteRouteKeyIndexer(IndentedTextWriter writer, string scopeType, TypeInfo valueType)
    {
      var indentLevel = writer.Indent;

      if (!valueType.AnnotationsEnabled)
      {
        writer.Indent = 0;
        writer.WriteLine("#nullable disable");
        writer.Indent = indentLevel;
      }

      writer.Write($"public {valueType.FullyQualifiedName} this[global::{GeneratorSupport.RootNamespace}.RouteKey<{scopeType}, {valueType.FullyQualifiedName}> key] ");
      writer.WriteLine("{ set => RouteValues[key.Name] = value; }");

      if (!valueType.AnnotationsEnabled)
      {
        writer.Indent = 0;
        writer.WriteLine("#nullable restore");
      }

      writer.Indent = indentLevel;
    }
    private static void WriteRouteValuesClass(IndentedTextWriter writer, GeneratorOptions options, IMvcObjectInfo item, IMvcMethodInfo method)
    {
      var methodClassName = $"{method.UniqueName}RouteValues";

      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Represents route values for routes to <see cref=\"{CSharpSupport.EscapeXmlDocType($"{item.FullyQualifiedTypeName}.{method.FullyQualifiedMethodDeclaration}")}\"/>.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine(CSharpSupport.GetGeneratedCodeAttribute());
      writer.WriteLine(CSharpSupport.GetExcludeFromCodeCoverageAttribute());
      writer.WriteLine($"{options.GeneratedAccessModifier} sealed class {methodClassName} : global::{GeneratorSupport.RootNamespace}.I{item.Noun}RouteValues");
      writer.WriteLine("{");
      writer.Indent++;

      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// The name of the {item.Noun.ToLowerInvariant()} for the route.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine($"public string {item.Noun}Name => \"{item.RouteValue}\";");

      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// The name of the {item.DivisionName.ToLowerInvariant()} for the route.");
      writer.WriteLine("/// </summary>");
      writer.Write("public string");
      if (method.DivisionRouteValue is null)
      {
        writer.Write("?");
      }
      writer.Write($" {item.DivisionName}Name => ");
      writer.Write(method.DivisionRouteValue is null ? "null" : $"\"{CSharpSupport.EscapeStringLiteral(method.DivisionRouteValue)}\"");
      writer.WriteLine(";");

      writer.WriteLine("/// <summary>");
      writer.WriteLine("/// Values for the route.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine("public global::Microsoft.AspNetCore.Routing.RouteValueDictionary RouteValues { get; } = new global::Microsoft.AspNetCore.Routing.RouteValueDictionary();");

      if (item.Properties.Count > 0)
      {
        WriteRouteValuesClassMembers(writer, "PropertyData", item.Properties.Select(x => x.Type), item.FullyQualifiedTypeName, MemberType.Property);
      }

      if (method.Parameters.Count > 0)
      {
        WriteRouteValuesClassMembers(writer, $"{method.UniqueName}.ParameterData", method.Parameters.Select(x => x.Type), $"{item.FullyQualifiedTypeName}.{method.FullyQualifiedMethodDeclaration}", MemberType.Parameter);
      }

      writer.Indent--;
      writer.WriteLine("}");

      if (method.Parameters.Count > 0)
      {
        writer.WriteLine();
        writer.WriteLine($"namespace {method.UniqueName}");
        writer.WriteLine("{");
        writer.Indent++;

        WriteParameterDataClass(writer, options, item, method);

        writer.Indent--;
        writer.WriteLine("}");
      }
    }
    private static void WriteRouteValuesClassMembers(IndentedTextWriter writer, string memberDataClassName, IEnumerable<TypeInfo> memberTypes, string fullyQualifiedSourceIdentifier, MemberType memberType)
    {
      writer.WriteLine();
      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// {memberType.TitleCasePluralNoun} of <see cref=\"{CSharpSupport.EscapeXmlDocType(fullyQualifiedSourceIdentifier)}\"/> which can be used in the route.");
      writer.WriteLine("/// </summary>");
      writer.Write($"public {memberDataClassName} {memberType.TitleCasePluralNoun}");
      writer.Write(" { get; } = new ");
      writer.WriteLine($"{memberDataClassName}();");

      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Removes a {memberType.TitleCaseNoun.ToLowerInvariant()} value from the route.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine("/// <typeparam name=\"T\">The type of values applicable to the key.</typeparam>");
      writer.WriteLine("/// <param name=\"key\">The key for the route.</param>");
      writer.WriteLine("/// <returns><see langword=\"true\"/> if the element is successfully found and removed; otherwise <see langword=\"false\"/>.</returns>");
      writer.WriteLine($"public bool Remove<T>(global::{GeneratorSupport.RootNamespace}.RouteKey<{memberDataClassName}, T> key) => RouteValues.Remove(key.Name);");

      writer.WriteLine("/// <summary>");
      writer.WriteLine($"/// Sets a {memberType.TitleCaseNoun.ToLowerInvariant()} value for the route.");
      writer.WriteLine("/// </summary>");
      writer.WriteLine("/// <typeparam name=\"T\">The type of values applicable to the key.</typeparam>");
      writer.WriteLine("/// <param name=\"key\">The key for the route.</param>");
      writer.WriteLine("/// <param name=\"value\">The value for the route.</param>");
      writer.WriteLine($"public void Set<T>(global::{GeneratorSupport.RootNamespace}.RouteKey<{memberDataClassName}, T> key, T value) => RouteValues[key.Name] = value;");

      var parameterTypes = ConsolidateTypes(memberTypes);

      foreach (var parameterType in parameterTypes.OrderBy(x => x.FullyQualifiedName))
      {
        writer.WriteLine("/// <summary>");
        writer.WriteLine($"/// Sets a {memberType.TitleCaseNoun.ToLowerInvariant()} value for the route.");
        writer.WriteLine("/// </summary>");
        writer.WriteLine("/// <param name=\"key\">The key for the route.</param>");
        WriteRouteKeyIndexer(writer, scopeType: memberDataClassName, valueType: parameterType);
      }
    }
    private static List<TypeInfo> ConsolidateTypes(IEnumerable<TypeInfo> types)
    {
      // 1. Group all types by their names without nullable reference type annotations.
      // 2. If any within the group are from an annotation disabled context, take that and ignore the rest.
      // 3. If all remaining types are identical, return that, otherwise fall back to a nullable disabled context.

      var results = new List<TypeInfo>();

      foreach (var typeGroup in types.GroupBy(x => x.FullyQualifiedNameSansAnnotations, StringComparer.Ordinal))
      {
        var resultType = default(TypeInfo);

        foreach (var type in typeGroup)
        {
          if (!type.AnnotationsEnabled)
          {
            resultType = type;
            break;
          }

          if (resultType is null)
          {
            resultType = type;
            continue;
          }
          
          if (!string.Equals(resultType.FullyQualifiedName, type.FullyQualifiedName, StringComparison.Ordinal))
          {
            resultType = new TypeInfo(type.FullyQualifiedNameSansAnnotations, type.FullyQualifiedNameSansAnnotations, annotationsEnabled: false);
          }
        }

        results.Add(resultType!);
      }

      return results;
    }
  }

  internal sealed class MemberType
  {
    private MemberType(string titleCaseNoun, string titleCasePluralNoun)
    {
      TitleCaseNoun = titleCaseNoun;
      TitleCasePluralNoun = titleCasePluralNoun;
    }

    public string TitleCaseNoun { get; }
    public string TitleCasePluralNoun { get; }

    public static MemberType Parameter { get; } = new MemberType("Parameter", "Parameters");
    public static MemberType Property { get; } = new MemberType("Property", "Properties");
  }

  internal static class CSharpSupport
  {
    public static bool IsValidIdentifier(string value)
      => IdentifierRegex.IsMatch(value);
    public static string CamelToPascalCase(string value)
      => value.Length <= 1
        ? value.ToUpperInvariant()
        : value.Substring(0, 1).ToUpperInvariant() + value.Substring(1);
    public static string PascalToCamelCase(string value)
      => value.Length <= 1
        ? value.ToLowerInvariant()
        : value.Substring(0, 1).ToLowerInvariant() + value.Substring(1);
    public static string EscapeCharLiteral(char value)
      => value switch
      {
        '\'' => "\\'",
        '\\' => "\\\\",
        _ => value.ToString()
      };
    public static string EscapeStringLiteral(string value)
      => value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    public static string EscapeXmlDocType(string value)
      => value.Replace('<', '{').Replace('>', '}');
    public static string GetGeneratedCodeAttribute()
      => $"[global::System.CodeDom.Compiler.GeneratedCode(\"{AssemblyName.Name}\", \"{AssemblyName.Version}\")]";
    public static string GetExcludeFromCodeCoverageAttribute()
      => "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]";

    private static Regex GetIdentifierRegex()
    {
      // Based on following link, without escape sequences or contextual keywords
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#643-identifiers
      var formattingCharacter = "[\\p{Cf}]";
      var connectingCharacter = "[\\p{Pc}]";
      var decimalDigitCharacter = "[\\p{Nd}]";
      var combiningCharacter = "[\\p{Mn}\\p{Mc}]";
      var letterCharacter = "[\\p{L}\\p{Nl}]";
      var identifierPartCharacter = $"({letterCharacter}|{decimalDigitCharacter}|{connectingCharacter}|{combiningCharacter}|{formattingCharacter})";
      var underscoreCharacter = "_";
      var identifierStartCharacter = $"({letterCharacter}|{underscoreCharacter})";
      var basicIdentifier = $"{identifierStartCharacter}({identifierPartCharacter})*";
      var escapedIdentifier = $"@{basicIdentifier}";
      var availableIdentifier = basicIdentifier;
      var simpleIdentifier = $"({availableIdentifier}|{escapedIdentifier})";
      var identifier = $"^{simpleIdentifier}$";

      return new Regex(identifier, RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.ExplicitCapture | RegexOptions.CultureInvariant, TimeSpan.FromSeconds(5));
    }

    private static Regex IdentifierRegex { get; } = GetIdentifierRegex();
    private static AssemblyName AssemblyName { get; } = Assembly.GetAssembly(typeof(GeneratorSupport)).GetName();
  }
}
